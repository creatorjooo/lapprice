import { useState, useEffect, useCallback } from 'react';
import type { Product, ProductType, PriceHistory } from '@/types';
import { laptops as staticLaptops } from '@/data/laptops';
import { monitors as staticMonitors } from '@/data/monitors';
import { desktops as staticDesktops } from '@/data/desktops';

const API_BASE = (import.meta.env.VITE_API_URL || '').replace(/\/$/, '');
const CACHE_KEY_PREFIX = 'lapprice_products_';
const CACHE_TTL = 5 * 60 * 1000; // 5분 캐시

interface ProductsResponse {
  type: string;
  total: number;
  verifiedOnly?: boolean;
  lastSync: string | null;
  syncCount: number;
  stats: {
    total: number;
    autoGenerated: number;
    manual: number;
    added: number;
    updated: number;
  } | null;
  products: Product[];
}

interface UseProductsResult<T extends Product> {
  products: T[];
  isLoading: boolean;
  isFromApi: boolean;
  lastSync: string | null;
  totalCount: number;
  error: string | null;
  refresh: () => void;
}

/**
 * 상품 데이터를 API에서 자동 로드하는 훅
 * API 실패 시 정적 데이터로 fallback
 */
export function useProducts<T extends Product = Product>(
  productType: ProductType,
  options?: {
    category?: string;
    enabled?: boolean;
    verifiedOnly?: boolean;
  }
): UseProductsResult<T> {
  const [products, setProducts] = useState<T[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isFromApi, setIsFromApi] = useState(false);
  const [lastSync, setLastSync] = useState<string | null>(null);
  const [totalCount, setTotalCount] = useState(0);
  const [error, setError] = useState<string | null>(null);
  const [refreshVersion, setRefreshVersion] = useState(0);

  const { category, enabled = true, verifiedOnly = true } = options || {};

  // 정적 데이터 fallback
  const getStaticData = useCallback((): T[] => {
    switch (productType) {
      case 'laptop': return staticLaptops as unknown as T[];
      case 'monitor': return staticMonitors as unknown as T[];
      case 'desktop': return staticDesktops as unknown as T[];
      default: return [];
    }
  }, [productType]);

  // 로컬 캐시 확인
  const getCachedProducts = useCallback((): ProductsResponse | null => {
    try {
      const cacheKey = `${CACHE_KEY_PREFIX}${productType}_${category || 'all'}_${verifiedOnly ? 'verified' : 'all'}`;
      const cached = sessionStorage.getItem(cacheKey);
      if (!cached) return null;
      
      const { data, timestamp } = JSON.parse(cached);
      if (Date.now() - timestamp > CACHE_TTL) {
        sessionStorage.removeItem(cacheKey);
        return null;
      }
      return data;
    } catch {
      return null;
    }
  }, [productType, category, verifiedOnly]);

  // 캐시 저장
  const setCachedProducts = useCallback((data: ProductsResponse) => {
    try {
      const cacheKey = `${CACHE_KEY_PREFIX}${productType}_${category || 'all'}_${verifiedOnly ? 'verified' : 'all'}`;
      sessionStorage.setItem(cacheKey, JSON.stringify({ data, timestamp: Date.now() }));
    } catch { /* sessionStorage 꽉 찬 경우 무시 */ }
  }, [productType, category, verifiedOnly]);

  // API에서 상품 로드
  useEffect(() => {
    if (!enabled) return;

    let cancelled = false;

    async function fetchProducts() {
      setIsLoading(true);
      setError(null);

      // 1. 로컬 캐시 확인 (refresh 시 스킵)
      if (refreshVersion === 0) {
        const cached = getCachedProducts();
        if (cached) {
          setProducts(cached.products as T[]);
          setIsFromApi(true);
          setLastSync(cached.lastSync);
          setTotalCount(cached.total);
          setIsLoading(false);
          return;
        }
      }

      // 2. API 호출 시도 — AbortController로 브라우저 호환성 확보
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), 5000);

      try {
        const params = new URLSearchParams({ type: productType, limit: '200' });
        if (category) params.set('category', category);
        params.set('verifiedOnly', String(verifiedOnly));
        
        const response = await fetch(`${API_BASE}/api/products?${params}`, {
          signal: controller.signal,
        });

        clearTimeout(timeout);

        if (cancelled) return;
        if (!response.ok) throw new Error(`API 오류: ${response.status}`);

        const data: ProductsResponse = await response.json();
        
        if (Array.isArray(data.products)) {
          setProducts(data.products as T[]);
          setIsFromApi(true);
          setLastSync(data.lastSync);
          setTotalCount(data.total);
          setCachedProducts(data);
          setIsLoading(false);
          return;
        }
        
        throw new Error('API 응답 형식 오류');
      } catch (err) {
        clearTimeout(timeout);
        if (cancelled) return;
        // 3. Fallback: 정적 데이터 사용
        console.log(`[useProducts] ${productType} API 실패, 정적 데이터 사용:`, (err as Error).message);
        const staticData = getStaticData();
        setProducts(staticData);
        setIsFromApi(false);
        setLastSync(null);
        setTotalCount(staticData.length);
        setError((err as Error).message);
      }

      setIsLoading(false);
    }

    fetchProducts();

    return () => { cancelled = true; };
  }, [productType, category, enabled, refreshVersion, verifiedOnly, getCachedProducts, setCachedProducts, getStaticData]);

  const refresh = useCallback(() => {
    // 캐시 클리어 후 재로드
    try {
      const cacheKey = `${CACHE_KEY_PREFIX}${productType}_${category || 'all'}_${verifiedOnly ? 'verified' : 'all'}`;
      sessionStorage.removeItem(cacheKey);
    } catch { /* ignore */ }
    setRefreshVersion(v => v + 1);
  }, [productType, category, verifiedOnly]);

  return { products, isLoading, isFromApi, lastSync, totalCount, error, refresh };
}

/**
 * 가격 히스토리를 API에서 로드하는 훅
 */
export function usePriceHistory(productId: string | null) {
  const [history, setHistory] = useState<PriceHistory[]>([]);
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {
    if (!productId) return;

    setIsLoading(true);
    fetch(`${API_BASE}/api/products/price-history/${productId}`)
      .then(r => r.ok ? r.json() : Promise.reject())
      .then(data => {
        if (data.history && data.history.length > 0) {
          setHistory(data.history);
        }
      })
      .catch(() => { /* ignore */ })
      .finally(() => setIsLoading(false));
  }, [productId]);

  return { history, isLoading };
}

/**
 * 카탈로그 통계 조회
 */
export function useCatalogStats() {
  const [stats, setStats] = useState<Record<string, unknown> | null>(null);

  useEffect(() => {
    fetch(`${API_BASE}/api/products/stats`)
      .then(r => r.ok ? r.json() : null)
      .then(data => { if (data) setStats(data); })
      .catch(() => { /* ignore */ });
  }, []);

  return stats;
}
